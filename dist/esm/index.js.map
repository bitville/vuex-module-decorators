{"version":3,"file":"index.js","sources":["../../src/helpers.ts","../../src/module/staticGenerators.ts","../../src/vuexmodule.ts","../../src/module/stateFactory.ts","../../src/module/index.ts","../../src/submodule.ts","../../src/action.ts","../../src/mutation.ts","../../src/mutationaction.ts","../../src/index.ts"],"sourcesContent":["import { DynamicModuleOptions } from './moduleoptions'\nimport { VueConstructor } from 'vue'\nimport Vuex from 'vuex'\n\n/**\n * Takes the properties on object from parameter source and adds them to the object\n * parameter target\n * @param {object} target  Object to have properties copied onto from y\n * @param {object} source  Object with properties to be copied to x\n */\nexport function addPropertiesToObject(target: any, source: any) {\n  for (let k of Object.keys(source || {})) {\n    Object.defineProperty(target, k, {\n      get: () => source[k]\n    })\n  }\n}\n\n/**\n * Returns a namespaced name of the module to be used as a store getter\n * @param module\n */\nexport function getModuleName(modOpt: DynamicModuleOptions): string {\n  return getStaticName(getModulePath(modOpt))\n}\n\nexport function getStaticName(path: string[]): string {\n  if (path.length === 0) {\n    return '$statics'\n  }\n  return '$statics.' + path.join('.')\n}\n\n/**\n * Returns a namespaced name of the module to be used as a store getter\n * @param module\n */\nexport function getModuleNamespace(modOpt: DynamicModuleOptions): string {\n  if (!modOpt.name) {\n    throw new Error(`ERR_GET_MODULE_NAME : Could not get module accessor.\n      Make sure your module has name, we can't make accessors for unnamed modules\n      i.e. @Module({ name: 'something' })`)\n  }\n  if (modOpt.namespaced) {\n    return `${modOpt.name}`\n  }\n  return ''\n}\n\n/**\n * Returns a namespaced path of the module to be used as a store getter\n * @param module\n */\nexport function getModulePath(modOpt: DynamicModuleOptions): string[] {\n  if (!modOpt.name) {\n    throw new Error(`ERR_GET_MODULE_NAME : Could not get module accessor.\n      Make sure your module has name, we can't make accessors for unnamed modules\n      i.e. @Module({ name: 'something' })`)\n  }\n  return modOpt.name.split('/')\n}\n\nexport function getNamespacedKey(namespace: string | null | undefined, key: string) {\n  return namespace ? `${namespace}/${key}` : key\n}\n\nexport function install<R>(Vue: VueConstructor) {\n  Vue.use(Vuex)\n  Vue.mixin({ beforeCreate: storeInit })\n\n  function storeInit(this: Vue) {\n    Object.defineProperty(this, '$stock', {\n      get: (): R => this.$store.getters.$statics\n    })\n  }\n}\n","import { VuexModule } from '../vuexmodule'\nimport { getNamespacedKey } from '../helpers'\nimport { Module, Store } from 'vuex'\n\nexport function staticStateGenerator<S extends Object, R>(\n  statics: any,\n  module: Module<S, R>,\n  store: Store<any>,\n  path: string[]\n) {\n  const stateFactory = module.state\n  if (stateFactory === undefined) {\n    return\n  }\n  const state = typeof stateFactory === 'function' ? (stateFactory as () => S)() : stateFactory\n  const modules = module.modules || {}\n  let contextedState: S\n  Object.keys(state).forEach((key) => {\n    if (state.hasOwnProperty(key) && !modules.hasOwnProperty(key)) {\n      // If not undefined or function means it is a state value\n      if (['undefined', 'function'].indexOf(typeof (state as any)[key]) === -1) {\n        Object.defineProperty(statics, key, {\n          get(this: VuexModule) {\n            if (contextedState === undefined) {\n              contextedState = path.reduce((state, key) => state[key], store.state)\n            }\n            return (contextedState as any)[key]\n          },\n          enumerable: true\n        })\n      }\n    }\n  })\n}\n\nexport function staticGetterGenerator<S, R>(\n  statics: any,\n  module: Module<S, R>,\n  store: Store<R>,\n  namespace?: string | null\n) {\n  const getters = module.getters || {}\n  Object.keys(getters).forEach((key) => {\n    const namespacedKey = getNamespacedKey(namespace, key)\n    Object.defineProperty(statics, key, {\n      get() {\n        return store.getters[namespacedKey]\n      },\n      enumerable: true\n    })\n  })\n}\n\nexport function staticMutationGenerator<S, R>(\n  statics: any,\n  module: Module<S, R>,\n  store: Store<R>,\n  namespace?: string | null\n) {\n  const mutations = module.mutations || {}\n  Object.keys(mutations).forEach((key) => {\n    const namespacedKey = getNamespacedKey(namespace, key)\n    statics[key] = function(...args: any[]) {\n      return store.commit(namespacedKey, ...args)\n    }\n  })\n}\n\nexport function staticActionGenerator<S, R>(\n  statics: any,\n  module: Module<S, R>,\n  store: Store<R>,\n  namespace?: string | null\n) {\n  const actions = module.actions || {}\n  Object.keys(actions).forEach((key) => {\n    const namespacedKey = (actions[key] as any).root ? key : getNamespacedKey(namespace, key)\n    statics[key] = function(...args: any[]) {\n      return store.dispatch(namespacedKey, ...args)\n    }\n  })\n}\n\nexport function staticModuleGenerator<S, R>(\n  module: Module<S, R>,\n  store: Store<R>,\n  path: string[] = [],\n  namespace?: string | null,\n  recursive: boolean = true\n) {\n  const statics = Object.create((module as any).prototype || null)\n  staticStateGenerator(statics, module, store, path)\n  staticGetterGenerator(statics, module, store, namespace)\n  staticMutationGenerator(statics, module, store, namespace)\n  staticActionGenerator(statics, module, store, namespace)\n  if (recursive) {\n    const modules = module.modules || {}\n    Object.keys(modules).forEach((key) => {\n      const subModule = modules[key]\n      // TODO: if not namespaced should statics be flatten?\n      const subNamespace = subModule.namespaced ? getNamespacedKey(namespace, key) : namespace\n      const subPath = path.concat(key)\n      const subStaics = staticModuleGenerator(subModule, store, subPath, subNamespace, recursive)\n      statics[key] = subStaics\n    })\n  }\n  return statics as S\n}\n","import {\n  ActionTree,\n  GetterTree,\n  Module as Mod,\n  ModuleTree,\n  MutationTree,\n  Store,\n  ActionContext,\n  Payload,\n  StoreOptions\n} from 'vuex'\nimport { getStaticName, getNamespacedKey } from './helpers'\nimport { staticModuleGenerator } from './module/staticGenerators'\n\nexport class Context<S, R = any> implements ActionContext<S, R> {\n  namespace?: string\n  path!: string[]\n  context!: Store<S> | ActionContext<S, R>\n  state!: S\n  rootState!: R\n  getters: any // not implemented\n  rootGetters: any\n  namespaced<P extends Payload>(key: string | P) {\n    if (!this.namespace) {\n      return key\n    }\n    if (typeof key === 'string') {\n      return `${this.namespace}/${key}`\n    } else {\n      key.type = `${this.namespace}/${key.type}`\n      return key\n    }\n  }\n  getter(key: string) {\n    return this.getters[this.namespaced(key) as string]\n  }\n  dispatch<P extends Payload>(key: string | P, ...args: any[]) {\n    return this.context.dispatch(this.namespaced(key) as any, ...args)\n  }\n  commit<P extends Payload>(key: string | P, ...args: any[]) {\n    return this.context.commit(this.namespaced(key) as any, ...args)\n  }\n  constructor(context: Store<S> | ActionContext<S, R>, path: string[] = [], namespace?: string) {\n    this.context = context\n    this.path = path\n    this.namespace = namespace\n    this.state = path.reduce((state, key) => state[key], context.state as any)\n    this.getters = this.context.getters\n    context = context as ActionContext<S, R>\n    this.rootGetters = context.rootGetters ?? context.getters\n    this.rootState = context.rootState ?? (context.state as any)\n  }\n}\n\nexport class VuexModule<S = ThisType<any>, R = any> {\n  /*\n   * To use with `extends Class` syntax along with decorators\n   */\n  static namespaced?: boolean\n  static state?: any | (() => any)\n  static getters?: GetterTree<any, any>\n  static actions?: ActionTree<any, any>\n  static mutations?: MutationTree<any>\n  static modules?: ModuleTree<any>\n  static factory?: () => any\n\n  context!: ActionContext<S, R>\n\n  static create<S>(module: Mod<S, any>) {\n    const result = Object.assign({}, module)\n    return result as typeof VuexModule\n  }\n}\n\ntype ConstructorOf<C> = {\n  new (...args: any[]): C\n}\n\ninterface ModuleMap extends Mod<any, any> {\n  modules?: { [key: string]: ModuleMap }\n  keys?: string[]\n}\n\nexport function installStatics(\n  root: any,\n  module: ModuleMap,\n  statics: any,\n  path: string[] = [],\n  namespace?: string,\n  recursive: boolean = true\n) {\n  root[getStaticName(path)] = statics\n  const moduleMap: ModuleMap = {\n    namespaced: module.namespaced,\n    modules: {}\n  }\n\n  const prefix = namespace ? `${namespace}/$statics/` : '$statics/'\n  const keys = moduleMap.keys || []\n  const actionKeys = Object.keys(module.actions || {})\n  const gettersKey = Object.keys(module.getters || {})\n  moduleMap.keys = keys.concat(actionKeys, gettersKey)\n  moduleMap.keys.forEach((key) => (root[prefix + key] = statics))\n\n  const modules = module.modules || {}\n  if (recursive) {\n    Object.keys(modules).forEach((key) => {\n      const subModule = modules[key]\n      const subNamespace = subModule.namespaced ? getNamespacedKey(namespace, key) : namespace\n      moduleMap.modules![key] = installStatics(\n        root,\n        subModule,\n        statics[key],\n        path.concat(key),\n        subNamespace,\n        recursive\n      )\n    })\n  }\n  return moduleMap\n}\n\nexport interface VuexStore<S> extends Store<S> {\n  getters: { $statics: S }\n}\n\nexport function newStore<M extends VuexModule>(module: ConstructorOf<M>): VuexStore<M>\nexport function newStore<S>(module: StoreOptions<S>): VuexStore<S>\nexport function newStore<S, M extends VuexModule>(\n  module: StoreOptions<S> | (StoreOptions<S> & ConstructorOf<M>)\n) {\n  const store = new Store(module)\n  const statics = staticModuleGenerator(module, store)\n    /// store.getters.$static.path.to.module\n    /// store.getters['$static.path.to.module']\n    /// store.getters['path/to/namepace/$static']\n  ;(store as any)._vmdModuleMap = installStatics(store.getters, module, statics)\n\n  return store\n}\n","import { Module as Mod } from 'vuex'\n\nconst reservedKeys = [\n  'namespaced',\n  'state',\n  'getters',\n  'mutations',\n  'actions',\n  'modules',\n  'commit',\n  'dispatch',\n  'factory',\n  'context',\n  'namespace',\n  'path'\n]\nexport function stateFactory<S>(module: Function & Mod<S, any>) {\n  const state = new module.prototype.constructor()\n  const modules = module.modules || {}\n  const s = {} as S\n  Object.keys(state).forEach((key: string) => {\n    if (reservedKeys.indexOf(key) !== -1) {\n      if (typeof state[key] !== 'undefined') {\n        throw new Error(\n          `ERR_RESERVED_STATE_KEY_USED: You cannot use the following\n        [${reservedKeys.join(', ')}]\n        as fields in your module. These are reserved as they have special purpose in Vuex`\n        )\n      }\n      return\n    }\n    if (state.hasOwnProperty(key) && !modules.hasOwnProperty(key)) {\n      if (typeof state[key] !== 'function') {\n        ;(s as any)[key] = state[key]\n      }\n    }\n  })\n\n  return s\n}\n","import { GetterTree, Module as Mod } from 'vuex'\nimport { DynamicModuleOptions, ModuleOptions } from '../moduleoptions'\nimport { stateFactory as sf } from './stateFactory'\nimport { addPropertiesToObject, getModuleName, getModuleNamespace, getModulePath } from '../helpers'\nimport { staticModuleGenerator } from './staticGenerators'\nimport { installStatics } from '../vuexmodule'\n\nfunction registerDynamicModule<S>(module: Mod<S, any>, modOpt: DynamicModuleOptions) {\n  if (!modOpt.name) {\n    throw new Error('Name of module not provided in decorator options')\n  }\n\n  if (!modOpt.store) {\n    throw new Error('Store not provided in decorator options when using dynamic option')\n  }\n\n  const oldStatics = modOpt.store.getters.$statics\n  const moduleMap = (modOpt.store as any)._vmdModuleMap\n  modOpt.store.registerModule(\n    modOpt.name, // TODO: Handle nested modules too in future\n    module,\n    { preserveState: modOpt.preserveState || false }\n  )\n  if (moduleMap && oldStatics) {\n    installStatics(modOpt.store.getters, moduleMap, oldStatics)\n    const path = getModulePath(modOpt)\n    const name = path[path.length - 1]\n    const namespace = getModuleNamespace(modOpt)\n    const recursive = true\n    const statics = staticModuleGenerator(module, modOpt.store, path, namespace, recursive)\n    const parentStatics = path.slice(0, -1).reduce((s, key) => s[key], oldStatics)\n    parentStatics[name] = statics\n    const parentModuleMap = path.slice(0, -1).reduce((s, key) => s[key], moduleMap)\n    parentModuleMap[name] = installStatics(\n      modOpt.store.getters,\n      module,\n      statics,\n      path,\n      namespace,\n      recursive\n    )\n  }\n}\n\nfunction moduleDecoratorFactory<S>(moduleOptions: ModuleOptions) {\n  return function<TFunction extends Function>(constructor: TFunction): TFunction | void {\n    const module: Function & Mod<S, any> = constructor\n    const stateFactory = () => sf(module)\n    Object.defineProperty(constructor, 'factory', {\n      get() {\n        return stateFactory\n      }\n    })\n\n    if (!module.state) {\n      module.state = moduleOptions && moduleOptions.stateFactory ? stateFactory : stateFactory()\n    }\n    if (!module.getters) {\n      module.getters = {} as GetterTree<S, any>\n    }\n    if (!module.namespaced) {\n      module.namespaced = moduleOptions && moduleOptions.namespaced\n    }\n    Object.getOwnPropertyNames(module.prototype).forEach((funcName: string) => {\n      const descriptor = Object.getOwnPropertyDescriptor(\n        module.prototype,\n        funcName\n      ) as PropertyDescriptor\n      if (descriptor.get && module.getters) {\n        const staticKey = '$statics/' + funcName\n        module.getters[funcName] = function(\n          state: S,\n          getters: any,\n          rootState: any,\n          rootGetters: any\n        ) {\n          const context = { state, getters, rootState, rootGetters }\n          let moduleAccessor\n          if (getters[staticKey]) {\n            moduleAccessor = getters[staticKey]\n            moduleAccessor.context = context\n          } else {\n            moduleAccessor = { context }\n            addPropertiesToObject(moduleAccessor, state)\n            addPropertiesToObject(moduleAccessor, getters)\n          }\n          const got = (descriptor.get as Function).call(moduleAccessor)\n          return got\n        }\n      }\n    })\n    const modOpt = moduleOptions as DynamicModuleOptions\n\n    if (modOpt.dynamic) {\n      registerDynamicModule(module, modOpt)\n    }\n    return constructor\n  }\n}\n\nexport function Module<S>(module: Function & Mod<S, any>): void\nexport function Module<S>(options: ModuleOptions): ClassDecorator\n\nexport function Module<S>(modOrOpt: ModuleOptions | (Function & Mod<S, any>)) {\n  if (typeof (modOrOpt as any) === 'function') {\n    /*\n     * @Module decorator called without options (directly on the class definition)\n     */\n    moduleDecoratorFactory({})(modOrOpt as Function & Mod<S, any>)\n  } else {\n    /*\n     * @Module({...}) decorator called with options\n     */\n    return moduleDecoratorFactory(modOrOpt)\n  }\n}\n","import { Module as Mod } from 'vuex'\nimport { VuexModule } from './vuexmodule'\n\nexport interface SubmoduleDecoratorParams<S, R> {\n  module: Mod<S, R>\n  namespaced?: boolean\n  init?: () => S | S\n}\n\nfunction submoduleDecoratorFactory<S, R>(\n  params: SubmoduleDecoratorParams<S, R>\n): PropertyDecorator {\n  return function<T extends Object>(target: T, key: string | symbol) {\n    const module = target.constructor as Mod<T, any>\n    if (!module.hasOwnProperty('modules')) {\n      module.modules = Object.assign({}, module.modules)\n    }\n    const subModule = VuexModule.create(params.module)\n    if (params.namespaced === undefined && subModule.namespaced === undefined) {\n      /// unlike module, submodule's namespace is default to true\n      subModule.namespaced = true\n    } else if (params.namespaced !== undefined) {\n      subModule.namespaced = params.namespaced\n    }\n    if (params.init !== undefined) {\n      subModule.state = params.init\n    }\n    module.modules![key as string] = subModule\n  }\n}\n\nexport function Submodule<T>(target: T, key: string | symbol): void\nexport function Submodule<T, S = any, R = any>(\n  params: SubmoduleDecoratorParams<S, R>\n): PropertyDecorator\n\n/**\n * The @SubModule decorator turns this into an submodule\n *\n * @param paramsOrTarget the params or the target class\n * @param key the name of the submodule\n * @constructor\n */\nexport function Submodule<T, S, R, K, M extends K>(\n  paramsOrTarget: SubmoduleDecoratorParams<S, R> | M,\n  key?: string | symbol\n): ((target: T, key: string | symbol) => void) | void {\n  if (!key) {\n    /*\n     * This is the case when `paramsOrTarget` is params.\n     * i.e. when used as -\n     * <pre>\n        @Submodule({module: MySubModule})\n        subName!: MySubModule\n     * </pre>\n     */\n    return submoduleDecoratorFactory(paramsOrTarget as SubmoduleDecoratorParams<S, R>)\n  } else {\n    /*\n     * This is the case when `paramsOrTarget` is target. not support by now\n     * i.e. when used as -\n     * <pre>\n        @Submodule\n        subName!: MySubModule\n     * </pre>\n     */\n    // submoduleDecoratorFactory({} as SubmoduleDecoratorParams<S, R>)(paramsOrTarget as K, key)\n    throw new Error(`ERR_SUBMODULE_NO_MODULE : Could not create module.\n      Make sure your submodule has type, we generate StoreOption for untyped submodules\n      i.e. @Submodule({ module: MyModule })`)\n  }\n}\n","import { Action as Act, ActionContext, Module as Mod, Payload } from 'vuex'\nimport { VuexModule } from './vuexmodule'\nimport { addPropertiesToObject, getModuleName } from './helpers'\n\n/**\n * Parameters that can be passed to the @Action decorator\n */\nexport interface ActionDecoratorParams {\n  commit?: string\n  rawError?: boolean\n  root?: boolean\n}\nfunction actionDecoratorFactory<T>(params?: ActionDecoratorParams): MethodDecorator {\n  const { commit = undefined, rawError = false, root = false } = params || {}\n  return function(target: Object, key: string | symbol, descriptor: TypedPropertyDescriptor<any>) {\n    const module = target.constructor as Mod<T, any>\n    if (!module.hasOwnProperty('actions')) {\n      module.actions = Object.assign({}, module.actions)\n    }\n    const actionFunction: Function = descriptor.value\n    const staticKey = '$statics/' + String(key)\n    const action: Act<typeof target, any> = async function(\n      context: ActionContext<typeof target, any>,\n      payload: Payload\n    ) {\n      try {\n        let actionPayload\n\n        if (context.getters[staticKey]) {\n          const moduleAccessor = context.getters[staticKey]\n          moduleAccessor.context = context\n          actionPayload = await actionFunction.call(moduleAccessor, payload)\n        } else {\n          const thisObj = { context }\n          addPropertiesToObject(thisObj, context.state)\n          addPropertiesToObject(thisObj, context.getters)\n          actionPayload = await actionFunction.call(thisObj, payload)\n        }\n        if (commit) {\n          context.commit(commit, actionPayload)\n        }\n        return actionPayload\n      } catch (e) {\n        throw rawError\n          ? e\n          : new Error(\n              'ERR_ACTION_ACCESS_UNDEFINED: Are you trying to access ' +\n                'this.someMutation() or this.someGetter inside an @Action? \\n' +\n                'That works only in dynamic modules. \\n' +\n                'If not dynamic use this.context.commit(\"mutationName\", payload) ' +\n                'and this.context.getters[\"getterName\"]' +\n                '\\n' +\n                new Error(`Could not perform action ${key.toString()}`).stack +\n                '\\n' +\n                e.stack\n            )\n      }\n    }\n    module.actions![key as string] = root ? { root, handler: action } : action\n  }\n}\n\nexport function Action<T, R>(\n  target: T,\n  key: string | symbol,\n  descriptor: TypedPropertyDescriptor<(...args: any[]) => R>\n): void\nexport function Action<T>(params: ActionDecoratorParams): MethodDecorator\n\n/**\n * The @Action decorator turns an async function into an Vuex action\n *\n * @param targetOrParams the module class\n * @param key name of the action\n * @param descriptor the action function descriptor\n * @constructor\n */\nexport function Action<T, R>(\n  targetOrParams: T | ActionDecoratorParams,\n  key?: string | symbol,\n  descriptor?: TypedPropertyDescriptor<(...args: any[]) => R>\n) {\n  if (!key && !descriptor) {\n    /*\n     * This is the case when `targetOrParams` is params.\n     * i.e. when used as -\n     * <pre>\n        @Action({commit: 'incrCount'})\n        async getCountDelta() {\n          return 5\n        }\n     * </pre>\n     */\n    return actionDecoratorFactory(targetOrParams as ActionDecoratorParams)\n  } else {\n    /*\n     * This is the case when @Action is called on action function\n     * without any params\n     * <pre>\n     *   @Action\n     *   async doSomething() {\n     *    ...\n     *   }\n     * </pre>\n     */\n    actionDecoratorFactory()(targetOrParams, key!, descriptor!)\n  }\n}\n","import { Module as Mod, Mutation as Mut, Payload } from 'vuex'\n\nexport function Mutation<T extends Object, R>(\n  target: T,\n  key: string | symbol,\n  descriptor: TypedPropertyDescriptor<(...args: any[]) => R>\n) {\n  const module = target.constructor as Mod<T, any>\n  if (!module.hasOwnProperty('mutations')) {\n    module.mutations = Object.assign({}, module.mutations)\n  }\n  const mutationFunction: Function = descriptor.value!\n  const mutation: Mut<typeof target> = function(state: typeof target, payload: Payload) {\n    mutationFunction.call(state, payload)\n  }\n  module.mutations![key as string] = mutation\n}\n","import { Action as Act, ActionContext, Module as Mod, Mutation as Mut, Payload, Store } from 'vuex'\n\nexport interface MutationActionParams<M> {\n  mutate?: (keyof Partial<M>)[]\n  rawError?: boolean\n  root?: boolean\n}\n\nfunction mutationActionDecoratorFactory<T extends Object>(params: MutationActionParams<T>) {\n  return function(\n    target: T,\n    key: string | symbol,\n    descriptor: TypedPropertyDescriptor<(...args: any[]) => Promise<Partial<T>>>\n  ) {\n    const module = target.constructor as Mod<T, any>\n    if (!module.hasOwnProperty('mutations')) {\n      module.mutations = Object.assign({}, module.mutations)\n    }\n    if (!module.hasOwnProperty('actions')) {\n      module.actions = Object.assign({}, module.actions)\n    }\n    const mutactFunction = descriptor.value as (payload: any) => Promise<any>\n\n    const action: Act<typeof target, any> = async function(\n      context: ActionContext<typeof target, any>,\n      payload: Payload\n    ) {\n      try {\n        const actionPayload = await mutactFunction.call(context, payload)\n        context.commit(key as string, actionPayload)\n      } catch (e) {\n        if (params.rawError) {\n          throw e\n        } else {\n          console.error('Could not perform action ' + key.toString())\n          console.error(e)\n          return Promise.reject(e)\n        }\n      }\n    }\n\n    const mutation: Mut<typeof target> = function(\n      state: typeof target | Store<T>,\n      payload: Payload & { [k in keyof T]: any }\n    ) {\n      if (!params.mutate) {\n        params.mutate = Object.keys(payload) as (keyof T)[]\n      }\n      for (let stateItem of params.mutate) {\n        if (state.hasOwnProperty(stateItem) && payload.hasOwnProperty(stateItem)) {\n          ;(state as T)[stateItem] = payload[stateItem]\n        } else {\n          throw new Error(`ERR_MUTATE_PARAMS_NOT_IN_PAYLOAD\n          In @MutationAction, mutate: ['a', 'b', ...] array keys must\n          match with return type = {a: {}, b: {}, ...} and must\n          also be in state.`)\n        }\n      }\n    }\n    module.actions![key as string] = params.root ? { root: true, handler: action } : action\n    module.mutations![key as string] = mutation\n  }\n}\n\nexport function MutationAction<K, T extends K>(\n  target: { [k in keyof T]: T[k] | null },\n  key: string | symbol,\n  descriptor: TypedPropertyDescriptor<(...args: any[]) => Promise<K>>\n): void\n\nexport function MutationAction<T>(\n  params: MutationActionParams<T>\n): (\n  target: T,\n  key: string | symbol,\n  descriptor: TypedPropertyDescriptor<(...args: any[]) => Promise<T>>\n) => void\n\n/**\n * The @MutationAction decorator turns this into an action that further calls a mutation\n * Both the action and the mutation are generated for you\n *\n * @param paramsOrTarget the params or the target class\n * @param key the name of the function\n * @param descriptor the function body\n * @constructor\n */\nexport function MutationAction<T, K, M extends K>(\n  paramsOrTarget: MutationActionParams<T> | M,\n  key?: string | symbol,\n  descriptor?: TypedPropertyDescriptor<(...args: any[]) => Promise<Partial<K>>>\n):\n  | ((\n      target: T,\n      key: string | symbol,\n      descriptor: TypedPropertyDescriptor<(...args: any[]) => Promise<Partial<T>>>\n    ) => void)\n  | void {\n  if (!key && !descriptor) {\n    /*\n     * This is the case when `paramsOrTarget` is params.\n     * i.e. when used as -\n     * <pre>\n        @MutationAction({mutate: ['incrCount']})\n        async getCountDelta() {\n          return {incrCount: 5}\n        }\n     * </pre>\n     */\n    return mutationActionDecoratorFactory(paramsOrTarget as MutationActionParams<T>)\n  } else {\n    /*\n     * This is the case when `paramsOrTarget` is target.\n     * i.e. when used as -\n     * <pre>\n        @MutationAction\n        async getCountDelta() {\n          return {incrCount: 5}\n        }\n     * </pre>\n     */\n    mutationActionDecoratorFactory({} as MutationActionParams<K>)(\n      paramsOrTarget as K,\n      key!,\n      descriptor!\n    )\n  }\n}\n","export { VuexModule, VuexStore, newStore, Context } from './vuexmodule'\nexport { Module } from './module'\nexport { Submodule } from './submodule'\nexport { Action } from './action'\nexport { Mutation } from './mutation'\nexport { MutationAction } from './mutationaction'\nimport { install } from './helpers'\nexport default {\n  install\n}\n"],"names":["stateFactory","sf"],"mappings":"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"}